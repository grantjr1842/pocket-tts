# Rust NumPy Validator

A complete example project showing how to validate a 100% Rust NumPy implementation against the comprehensive NumPy test examples.

## Quick Start

### 1. Setup the Project

```bash
cd test_data/rust_example_project
cargo build
```

### 2. Run the Tests

```bash
# Run all tests
cargo test

# Run with output
cargo test -- --nocapture

# Run specific test
cargo test test_array_creation_validation
```

### 3. Validate Against NumPy Test Data

```bash
# This will validate your implementation against the exact NumPy test cases
cargo test test_comprehensive_validation -- --nocapture
```

## Project Structure

```
rust-numpy-validator/
├── Cargo.toml                 # Dependencies
├── src/
│   ├── lib.rs                # Main library
│   ├── array.rs              # Array implementation
│   ├── functions.rs          # Mathematical functions
│   └── test_utils.rs         # Test validation utilities
├── tests/
│   └── integration_tests.rs  # Integration tests with NumPy data
└── README.md                  # This file
```

## How It Works

### 1. Test Data Loading

The project loads the JSON test cases generated from the original NumPy source:

```rust
let validator = NumPyTestValidator::with_path("../test_data");
let test_cases = validator.load_test_cases("array_creation")?;
```

### 2. Validation Framework

Each test case contains:
- **Function name** (e.g., "array", "add", "sqrt")
- **Input data** (parsed from JSON)
- **Expected output** (exact NumPy results)

### 3. Implementation Testing

Your Rust implementation is tested against the exact NumPy behavior:

```rust
// Load test case
let test_case = test_cases.iter().find(|tc| tc.function == "array").unwrap();

// Parse input
let input_array = TestArray::from_json(&test_case.input)?;

// Call your implementation
let result = crate::array::array(input_array.data)?;

// Validate against expected
assert_eq!(result.shape(), expected_shape);
assert!(arrays_close(result.data(), expected_data));
```

## Key Features

### ✅ Exact NumPy Compatibility
- Uses the same test data as NumPy 2.4.0
- Validates shape, dtype, and exact values
- Handles edge cases (NaN, Inf, empty arrays)

### ✅ Comprehensive Coverage
- Array creation functions
- Arithmetic operations
- Mathematical functions
- Statistical operations
- Cross-language CSV testing

### ✅ Performance Testing
- Benchmark against generated test data
- Measure operation timing
- Compare with NumPy reference

### ✅ Easy Integration
- Drop-in replacement for your existing Rust NumPy code
- Simple API matching NumPy patterns
- Comprehensive error handling

## Usage Examples

### Basic Array Operations

```rust
use rust_numpy_validator::*;

// Create arrays
let arr1 = array(vec![1.0, 2.0, 3.0])?;
let arr2 = Array::zeros(&[3, 3]);
let arr3 = Array::eye(4);

// Mathematical operations
let sum = add(&arr1.data(), &arr2.data())?;
let sqrt_result = sqrt(&arr1.data())?;

// Statistical operations
let mean_val = arr1.mean();
let max_val = arr1.max();
```

### Validation Against Test Data

```rust
let validator = NumPyTestValidator::new();

// Validate all array creation functions
let results = validator.validate_array_creation()?;
for result in results {
    println!("{}", result);
}

// Validate arithmetic functions
let arithmetic_results = validator.validate_arithmetic()?;

// Validate mathematical functions
let math_results = validator.validate_mathematical()?;
```

### Cross-Language Testing

```rust
// Load CSV data generated by Python
let csv_path = "../test_data/generated/array_(10,)_float64.csv";
let values = load_csv_data(csv_path)?;

// Test with your implementation
let arr = Array::from_vec(values);
let result = your_function(&arr)?;
```

## Test Categories

### Currently Supported
- **Array Creation**: array, zeros, ones, arange, linspace, eye
- **Arithmetic**: add, subtract, multiply, divide, power
- **Mathematical**: sqrt, abs, sin, cos, exp, log
- **Statistical**: sum, mean, min, max, argmin, argmax

### Ready to Add
- Array manipulation (reshape, transpose, concatenate)
- Linear algebra (dot, matmul, det, inv)
- Comparison operations (equal, greater, less)
- Edge cases (isnan, isinf, empty arrays)

## Integration with Your Project

### 1. Copy the Implementation

Copy the relevant files to your Rust NumPy project:

```bash
# Copy core implementations
cp src/array.rs /path/to/your/project/src/
cp src/functions.rs /path/to/your/project/src/

# Copy test utilities
cp src/test_utils.rs /path/to/your/project/src/
```

### 2. Update Your Cargo.toml

```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
csv = "1.3"
num-complex = "0.4"
num-traits = "0.2"
```

### 3. Add Tests

Copy the integration tests to your project:

```bash
cp tests/integration_tests.rs /path/to/your/project/tests/
```

### 4. Run Validation

```bash
cd /path/to/your/project
cargo test test_comprehensive_validation -- --nocapture
```

## Performance Benchmarking

The project includes performance testing using the generated test data:

```bash
cargo bench
```

This will benchmark:
- Array creation operations
- Mathematical functions
- Statistical operations
- Memory usage patterns

## Continuous Integration

Add to your CI pipeline:

```yaml
# .github/workflows/test.yml
- name: Test NumPy Compatibility
  run: |
    cargo test test_comprehensive_validation
    python ../test_data/validation_script.py
```

## Extending the Framework

### Adding New Functions

1. Implement the function in `functions.rs` or `array.rs`
2. Add test validation in `test_utils.rs`
3. Create integration tests in `tests/integration_tests.rs`

Example:
```rust
// In functions.rs
pub fn new_function(a: &[f64]) -> Result<Vec<f64>, String> {
    // Your implementation
}

// In test_utils.rs
fn test_new_function(&self, test_case: &TestCase) -> Result<String, Box<dyn std::error::Error>> {
    let input_array = TestArray::from_json(&test_case.input)?;
    let result = crate::functions::new_function(&input_array.data)?;
    // Validate against expected...
    Ok("✅ new_function: PASSED".to_string())
}
```

### Adding New Test Categories

```rust
// In test_utils.rs
pub fn validate_new_category(&self) -> Result<Vec<String>, Box<dyn std::error::Error>> {
    let test_cases = self.load_test_cases("new_category")?;
    // Implementation...
}
```

## Troubleshooting

### Common Issues

1. **Test data not found**: Ensure the path to `../test_data` is correct
2. **JSON parsing errors**: Check that test data files exist and are valid JSON
3. **Shape mismatches**: Verify your array shape calculations
4. **Precision issues**: Use `arrays_close()` for floating-point comparisons

### Debug Tips

```rust
// Enable debug output
cargo test -- --nocapture

// Test specific cases
cargo test test_specific_array_case -- --nocapture

// Run individual categories
cargo test test_array_creation_validation -- --nocapture
```

## Next Steps

1. **Implement missing functions** using the test data as reference
2. **Add more test categories** as you implement more NumPy features
3. **Optimize performance** based on benchmark results
4. **Add comprehensive documentation** for your API
5. **Set up CI/CD** for continuous validation

This framework provides everything you need to ensure your 100% Rust NumPy port has exact API parity with the original NumPy implementation!
